---
layout: post
title: "异步代码测试方案 - jest+enzyme"
description: "jest异步代码测试方案"
category: tech
tags: [react, jest]
---
{% include JB/setup %}


官方文档介绍了3种异步的处理方案：[https://facebook.github.io/jest/docs/asynchronous.html#content](https://facebook.github.io/jest/docs/asynchronous.html#content)。

比较主流的是`promise`和`await/async`

### promise的异步处理

    test('the data is peanut butter', () => {
      return fetchData().then(data => {
        expect(data).toBe('peanut butter');
      });
    });

注意的是`fetchData`函数必须return了`promise`，且我们的单测必须有`return`关键词，该单测才会等待异步的执行完成，否则会直接跳到下一个单测案例。

### Async/Await 

如果你的代码是`async await`流，需要用下面这种方式处理：

    test('the data is peanut butter', async () => {
      await expect(fetchData()).resolves.toBe('peanut butter');
    });

这里要注意给单例的函数注明`async`关键词。

## 异步请求

异步代码多是异步请求的代码。下面示例异步请求的处理：

    import { mockRequest } from '../mockRequest.js';
    import { multiData } from './mockModuleData.js';

    describe('DataEdit render', () => {
      afterEach(fetchMock.restore)
      it('renders DataEdit correctly', () => {
        mockRequest('/pageModule/getData', multiData);
        const wrapper = mount(<DataModal />);
        return wrapper.node.fetchData(moduleInfo.moduleId).then(()=>{
          expect(toJson(wrapper)).toMatchSnapshot();
        })
      });
    })

## 嵌套的异步

很多场景我们是在一个异步请求完成后再进行了另一个异步请求，没关系，异步的处理是可嵌套的。

譬如以下的场景，组件调用`preFetchData`方法进行异步请求获得数据，然后我们在组件内部的input框填充了一个数据后触发了另一个方法`checkUrlValid`异步请求检查该数据的合法性。

我们可以这么写测试：

    it('change new type value', () => {
      const wrapper = mount(<view />);
      mockRequest('/page/getInfo', {});
      return wrapper.node.preFetchData().then(() => {
        wrapper.setState({
          visible: true
        })
        const modalWrapper = mount(wrapper.find('DialogWrap').node.getDialogElement());

        // error domainSign
        let errDomainSign = 'test'
        modalWrapper.find('input[name="domainSign"]').simulate('change', {
          target: { value: errDomainSign }
        });
        expect(wrapper.state().domainSign).toBe(errDomainSign)

        return wrapper.node.checkUrlValid(errDomainSign).then(() => {
          expect(wrapper.state().urlStatus).toEqual({
            "validateStatus": "error"
            , "help": errDomainSignRes.msg + ' ' + errDomainSignRes.detail
          })
        })

      })
    })
    
注意的是每个异步方法`promise.then`前面都加上`return`关键字告诉单测要等待异步返回就好。